/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/arrow.js":
/*!**********************!*\
  !*** ./src/arrow.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Arrow; });\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.js\");\n/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprite */ \"./src/sprite.js\");\n\r\n\r\n\r\nclass Arrow {\r\n  constructor(startPos, nextPos, mapPos, direction) {\r\n    this.currentPos = startPos;\r\n    this.nextPos = nextPos;\r\n    this.timeStart = 0;\r\n    this.delayMove = 100;\r\n    this.size = [60, 20]; \r\n    this.mapPos = mapPos;\r\n    this.sampleBoard = new _board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    this.direction = direction;\r\n    this.lastDir = \"right\"\r\n    this.moving = false;\r\n    this.destroyed = false;\r\n    this.sprites = {\r\n      \"up\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [30, 211], size: [40, 30] },\r\n        1: { pos: [40, 166], size: [40, 39] },\r\n        2: { pos: [85, 165], size: [40, 39] }}, \r\n        200\r\n      ), \r\n      \"right\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [32, 183], size: [60, 20] },\r\n        1: { pos: [40, 166], size: [40, 39] },\r\n        2: { pos: [85, 165], size: [40, 39] }},\r\n        200\r\n      ), \r\n      \"down\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [35, 286], size: [40, 30] },\r\n        1: { pos: [40, 166], size: [40, 39] },\r\n        2: { pos: [85, 165], size: [40, 39] }},\r\n        200\r\n      ), \r\n      \"left\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [40, 331], size: [60, 20] },\r\n        1: { pos: [50, 29], size: [34, 39] },\r\n        2: { pos: [15, 29], size: [34, 39] }},\r\n        200\r\n      )\r\n    }\r\n  }\r\n  \r\n  move(x, y) {\r\n    this.currentPos = [x, y];\r\n    this.nextPos = [x, y];\r\n    this.mapPos = [\r\n      (this.sampleBoard.tileWidth * x) + ((this.sampleBoard.tileWidth - this.size[0]) / 2), \r\n      (this.sampleBoard.tileHeight * y) + ((this.sampleBoard.tileHeight - this.size[1]) / 2)\r\n    ];\r\n  }\r\n\r\n  handleMove(currentTime) {\r\n    if (this.currentPos[0] === this.nextPos[0] && this.currentPos[1] === this.nextPos[1]) return false;\r\n    if ((currentTime - this.timeStart) >= this.delayMove ) {\r\n      this.move(this.nextPos[0], this.nextPos[1]);\r\n      this.moving = !this.moving\r\n    } else {\r\n      this.getMapPos();\r\n      this.checkDirectionAndAdjust(currentTime);\r\n      this.mapPos[0] = Math.round(this.mapPos[0]);\r\n      this.mapPos[1] = Math.round(this.mapPos[1]);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  getMapPos() {\r\n    this.mapPos[0] = (this.currentPos[0] * this.sampleBoard.tileWidth) + ((this.sampleBoard.tileWidth - this.size[0]) / 2);\r\n    this.mapPos[1] = (this.currentPos[1] * this.sampleBoard.tileHeight) + ((this.sampleBoard.tileHeight - this.size[1]) / 2);\r\n  }\r\n\r\n  checkDirectionAndAdjust(currentTime) {\r\n    if (this.nextPos[0] !== this.currentPos[0]) {\r\n      let pixelDist = (this.sampleBoard.tileWidth / this.delayMove) * (currentTime - this.timeStart);\r\n      if (this.nextPos[0] < this.currentPos[0]) {\r\n        this.mapPos[0] += (0 - pixelDist);\r\n      } else {\r\n        this.mapPos[0] += (pixelDist);\r\n      }\r\n    } else {\r\n      let pixelDist = (this.sampleBoard.tileHeight / this.delayMove) * (currentTime - this.timeStart);\r\n      if (this.nextPos[1] < this.currentPos[1]) {\r\n        this.mapPos[1] += (0 - pixelDist);\r\n      } else {\r\n        this.mapPos[1] += (pixelDist);\r\n      }\r\n    }\r\n  }\r\n\r\n  toIndex(x, y) {\r\n    return ((y * this.sampleBoard.mapWidth) + x);\r\n  }\r\n\r\n  isWalkable(x, y) {\r\n    if (x < 0 || x >= this.sampleBoard.mapWidth || y < 0 || y >= this.sampleBoard.mapHeight) return false;\r\n    if (this.sampleBoard.tileTypes[this.sampleBoard.gameMap[this.toIndex(x, y)]].floor !== this.sampleBoard.floorTypes.walkable) return false; \r\n    return true;\r\n  }\r\n\r\n  canMoveUp() {\r\n    return this.isWalkable(this.currentPos[0], this.currentPos[1] - 1);\r\n  }\r\n\r\n  canMoveDown() {\r\n    return this.isWalkable(this.currentPos[0], this.currentPos[1] + 1);\r\n  }\r\n\r\n  canMoveLeft() {\r\n    return this.isWalkable(this.currentPos[0] - 1, this.currentPos[1]);\r\n  }\r\n\r\n  canMoveRight() {\r\n    return this.isWalkable(this.currentPos[0] + 1, this.currentPos[1]);\r\n  }\r\n\r\n  moveUp(currentGameTime) {\r\n    this.nextPos[1] -= 1;\r\n    this.timeStart = currentGameTime;\r\n    if (this.lastDir === \"left\") this.direction = \"left\";\r\n    this.moving = true;\r\n  }\r\n  \r\n  moveDown(currentGameTime) {\r\n    this.nextPos[1] += 1;\r\n    this.timeStart = currentGameTime;\r\n    if (this.lastDir === \"left\") this.direction = \"left\";\r\n    this.moving = true;\r\n  }\r\n\r\n  moveLeft(currentGameTime) {\r\n    this.nextPos[0] -= 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"left\";\r\n    this.moving = true; \r\n  }\r\n\r\n  moveRight(currentGameTime) {\r\n    this.nextPos[0] += 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"right\";\r\n    this.moving = true;\r\n  }\r\n\r\n}\r\n\n\n//# sourceURL=webpack:///./src/arrow.js?");

/***/ }),

/***/ "./src/board.js":
/*!**********************!*\
  !*** ./src/board.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Board; });\n/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile */ \"./src/tile.js\");\n\r\n\r\nclass Board {\r\n  constructor() {\r\n    this.gameBoard = document.getElementById(\"gameBoard\"); \r\n    this.ctx = this.gameBoard.getContext('2d');\r\n    this.gameBoard.width = window.innerWidth;\r\n    this.gameBoard.height = window.innerHeight;\r\n    this.tileWidth = 70;\r\n    this.tileHeight = 70;\r\n    this.mapWidth = 36;\r\n    this.mapHeight = 36;\r\n    this.gameMap =  [\r\n  //   0   1   2   3  4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 \r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 29,// 0\r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 18, 15, 40, 40, 40, 15, 40, 40, 15, 40, 15, 40, 40, 40, 15, 29,// 1 \r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 21, 21, 21, 21, 21, 21, 21, 21, 21, 16, 38, 38, 38, 38, 14, 38, 38, 38, 38, 38, 38, 13, 38, 38, 29,// 2 \r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 18, 15, 40, 40, 40, 15, 40, 40, 15, 13, 38, 38, 32, 21, 21, 33, 16, 38, 32, 21, 21, 33, 16, 38, 29,// 3 \r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 16, 12, 38, 12, 13, 14, 38, 12, 14, 38, 14, 38, 29, 20, 20, 28, 16, 12, 29, 20, 20, 28, 16, 38, 29,// 4 \r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 16, 38, 32, 21, 21, 21, 21, 21, 33, 16, 38, 38, 29, 28, 21, 25, 16, 13, 24, 21, 29, 28, 16, 38, 29,// 5 \r\n      28, 21, 21, 21, 29, 20, 20, 20, 20, 20, 28, 16, 12, 29, 20, 20, 20, 20, 20, 28, 16, 12, 38, 29, 28, 18, 15, 38, 38, 40, 15, 29, 30, 33, 16, 29,// 6\r\n      28, 18, 40, 15, 29, 28, 21, 21, 21, 21, 25, 16, 38, 24, 21, 21, 21, 21, 21, 21, 16, 38, 14, 29, 28, 16, 41, 41, 41, 41, 38, 29, 20, 28, 16, 29,// 7\r\n      28, 16, 14, 38, 21, 21, 18, 40, 40, 40, 15, 38, 38, 40, 15, 15, 40, 40, 40, 15, 38, 38, 38, 29, 28, 16, 38, 38, 38, 38, 12, 29, 28, 21, 16, 29,// 8\r\n      28, 16, 12, 38, 15, 40, 14, 38, 38, 38, 38, 14, 38, 38, 38, 38, 38, 38, 38, 38, 14, 38, 38, 29, 28, 16, 13, 38, 12, 38, 38, 29, 28, 18, 12, 29,// 9\r\n      28, 16, 38, 38, 12, 14, 38, 14, 12, 14, 38, 41, 41, 38, 12, 38, 38, 14, 38, 38, 38, 38, 13, 29, 28, 16, 38, 38, 14, 38, 38, 29, 28, 16, 32, 31,// 10\r\n      28, 16, 38, 38, 38, 38, 38, 38, 14, 38, 13, 38, 38, 38, 14, 38, 13, 38, 12, 32, 33, 16, 38, 29, 28, 16, 41, 41, 41, 41, 38, 29, 28, 16, 29, 20,// 11\r\n      28, 16, 12, 13, 38, 38, 13, 38, 38, 12, 38, 38, 38, 38, 38, 38, 38, 38, 14, 29, 28, 16, 14, 21, 21, 16, 38, 38, 38, 38, 13, 21, 25, 16, 24, 33,// 12\r\n      28, 16, 14, 38, 32, 33, 16, 38, 38, 38, 14, 12, 38, 38, 12, 14, 38, 12, 38, 29, 28, 16, 38, 15, 15, 38, 38, 14, 38, 38, 38, 40, 15, 38, 38, 36,// 13\r\n      30, 21, 21, 21, 31, 30, 21, 21, 33, 21, 21, 21, 32, 21, 21, 21, 21, 21, 21, 31, 28, 16, 38, 32, 33, 16, 12, 38, 38, 38, 38, 32, 21, 33, 16, 36,// 14\r\n      20, 20, 20, 20, 20, 20, 20, 20, 28, 18, 40, 15, 29, 20, 20, 20, 20, 20, 20, 20, 28, 16, 14, 29, 28, 16, 41, 41, 41, 41, 38, 29, 20, 28, 16, 36,// 15\r\n      28, 21, 21, 21, 21, 21, 21, 21, 21, 16, 38, 38, 21, 21, 21, 21, 21, 21, 21, 21, 21, 16, 38, 29, 28, 16, 38, 13, 14, 38, 38, 29, 20, 28, 16, 36,// 16\r\n      28, 18, 15, 40, 40, 40, 40, 40, 15, 38, 38, 38, 15, 40, 40, 15, 15, 40, 40, 15, 40, 38, 38, 29, 30, 21, 33, 16, 38, 32, 21, 31, 28, 21, 16, 32,// 17\r\n      28, 16, 32, 21, 21, 21, 21, 21, 33, 16, 38, 12, 38, 38, 12, 38, 14, 38, 38, 14, 38, 38, 12, 29, 20, 20, 28, 16, 13, 29, 20, 20, 28, 18, 38, 29,// 18\r\n      28, 16, 29, 20, 20, 20, 20, 20, 28, 16, 14, 38, 35, 21, 21, 21, 21, 21, 21, 35, 16, 38, 38, 21, 21, 21, 25, 16, 38, 24, 21, 21, 21, 16, 13, 29,// 19\r\n      28, 16, 21, 21, 21, 29, 20, 20, 28, 16, 38, 38, 34, 18, 15, 40, 40, 15, 15, 34, 16, 38, 13, 40, 40, 15, 40, 14, 14, 40, 15, 40, 15, 38, 38, 29,// 20\r\n      28, 16, 38, 38, 38, 29, 20, 20, 30, 21, 21, 21, 37, 16, 38, 12, 38, 14, 38, 42, 21, 21, 21, 21, 33, 16, 13, 38, 38, 38, 32, 21, 33, 16, 12, 33,// 21\r\n      28, 16, 38, 12, 38, 29, 20, 20, 20, 20, 20, 20, 28, 16, 38, 14, 38, 12, 38, 29, 20, 20, 20, 20, 30, 21, 21, 21, 21, 21, 31, 20, 28, 16, 38, 36,// 22\r\n      28, 16, 32, 21, 21, 31, 20, 20, 20, 20, 20, 20, 28, 16, 38, 38, 14, 38, 12, 29, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 21, 16, 38, 36,// 23\r\n      28, 16, 29, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 16, 14, 38, 38, 14, 38, 29, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 18, 38, 14, 36,// 24\r\n      28, 16, 21, 21, 21, 21, 21, 29, 20, 20, 20, 20, 28, 16, 38, 38, 12, 38, 14, 29, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 28, 16, 12, 38, 36,// 25\r\n      28, 16, 40, 40, 15, 40, 40, 29, 20, 28, 21, 21, 34, 16, 38, 13, 32, 21, 21, 37, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 29, 30, 21, 33, 16, 36,// 26\r\n      30, 33, 16, 14, 38, 38, 38, 29, 20, 28, 18, 15, 21, 16, 38, 14, 29, 20, 20, 28, 18, 40, 15, 40, 40, 40, 40, 15, 15, 40, 29, 20, 20, 28, 16, 36,// 27\r\n      20, 28, 16, 38, 38, 14, 38, 21, 21, 21, 16, 38, 15, 38, 38, 12, 21, 21, 21, 21, 16, 32, 33, 14, 32, 21, 33, 16, 38, 38, 21, 21, 21, 21, 16, 36,// 28\r\n      20, 28, 16, 12, 38, 38, 38, 15, 40, 40, 38, 38, 32, 33, 16, 13, 40, 40, 15, 40, 38, 29, 30, 21, 31, 20, 28, 16, 38, 14, 15, 40, 40, 15, 12, 36,// 29\r\n      20, 30, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 31, 30, 21, 21, 21, 21, 21, 21, 21, 31, 20, 20, 20, 20, 30, 21, 21, 21, 21, 21, 21, 21, 21, 21,//30\r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,//31\r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,//32\r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,//33\r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,//34\r\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20//35\r\n    ]; \r\n    \r\n    this.viewPort = {\r\n      screen: [0, 0],\r\n      startTile: [0, 0],\r\n      endTile: [0, 0],\r\n      offset: [0, 0],\r\n      update: function(px, py) {\r\n        this.offset[0] = Math.floor((this.screen[0] / 2) - px);\r\n        this.offset[1] = Math.floor((this.screen[1] / 2) - py);\r\n        let tile = [ Math.floor(px / 70), Math.floor(py / 70) ];\r\n        this.startTile[0] = tile[0] - 1 - Math.ceil((this.screen[0] / 2) / 70);\r\n        this.startTile[1] = tile[1] - 1 - Math.ceil((this.screen[1] / 2) / 70);\r\n        if (this.startTile[0] < 0) this.startTile[0] = 0;\r\n        if (this.startTile[1] < 0) this.startTile[1] = 0;\r\n        this.endTile[0] = tile[0] + 1 + Math.ceil((this.screen[0] / 2) / 70);\r\n        this.endTile[1] = tile[1] + 1 + Math.ceil((this.screen[1] / 2) / 70);\r\n        if (this.endTile[0] >= 37) this.endTile[0] = 37 - 1;\r\n        if (this.endTile[1] >= 32) this.endTile[1] = 32 - 1;\r\n      }\r\n    }\r\n    \r\n    this.floorTypes = {\r\n      solid: 0,\r\n      walkable: 1\r\n    };\r\n\r\n    this.tileTypes = {\r\n      20: { type: \"outOfMap\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([14, 191], [70, 70]) },\r\n      21: { type: \"xWall\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([13, 102], [70, 70]) },\r\n      22: { type: \"xWallPillDown\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([103, 104], [70, 70]) },\r\n      23: { type: \"xWallPillUp\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([456, 108], [70, 70]) },\r\n      24: { type: \"xWallDoorFrameR\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([189, 101], [70, 70]) },\r\n      25: { type: \"xWallDoorFrameL\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([277, 105], [70, 69]) },\r\n      26: { type: \"xDoor\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([103, 194], [70, 70]) },\r\n      27: { type: \"xWallDecor\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([165, 106], [70, 70]) },\r\n      28: { type: \"yWallL\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([623, 107], [70, 70]) },\r\n      29: { type: \"yWallR\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([539, 106], [70, 70]) },\r\n      12: { type: \"groundReg\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([100, 7], [70, 70]) },\r\n      13: { type: \"groundReg2\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([189, 10], [70, 70]) },\r\n      14: { type: \"groundReg3\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([370, 12], [70, 70]) },\r\n      15: { type: \"groundTop\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([10, 7], [70, 70]) },\r\n      16: { type: \"groundL\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([459, 13], [70, 70]) },\r\n      17: { type: \"groundR\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([624, 15], [70, 70]) },\r\n      18: { type: \"groundLCorner\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([280, 10], [70, 70]) },\r\n      19: { type: \"groundRCorner\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([543, 14], [70, 70]) },\r\n      30: { type: \"bottomCornerPillL\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([194, 196], [70, 70]) },\r\n      31: { type: \"bottomCornerPillR\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([283, 197], [70, 70]) },\r\n      32: { type: \"bottomCornerUpL\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([368, 198], [70, 70]) },\r\n      33: { type: \"bottomCornerUpR\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([455, 198], [70, 70]) },\r\n      34: { type: \"narrowYL\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([198, 308], [70, 70]) },\r\n      35: { type: \"narrowRL\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([101, 308], [70, 70]) },\r\n      36: { type: \"mazeR\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([16, 310], [70, 70]) },\r\n      37: { type: \"narrowCustom\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([418, 308], [70, 70]) },\r\n      38: { type: \"groundBlank\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([510, 308], [70, 70]) },\r\n      40: { type: \"groundTopAlt\", floor: this.floorTypes.walkable, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([597, 308], [70, 70]) },\r\n      41: { type: \"fakeOut\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([370, 12], [70, 70]) },\r\n      42: { type: \"narrowC2\", floor: this.floorTypes.solid, sprite: new _tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([102, 395], [70, 70]) }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/board.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player */ \"./src/player.js\");\n/* harmony import */ var _monster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./monster */ \"./src/monster.js\");\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./board */ \"./src/board.js\");\n/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keys */ \"./src/keys.js\");\n/* harmony import */ var _arrow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./arrow */ \"./src/arrow.js\");\n/* harmony import */ var _sfxSprite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sfxSprite */ \"./src/sfxSprite.js\");\n/* harmony import */ var _scenery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scenery */ \"./src/scenery.js\");\n/* harmony import */ var _pathfinder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pathfinder */ \"./src/pathfinder.js\");\n\n\n\n\n\n\n\n\n\nclass Game {\n  constructor() {\n    this.board = new _board__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    this.player = new _player__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.redMonsters = [];\n    this.skullMonsters = [];\n    this.greenMonsters = [];\n    this.purpleMonsters = [];\n    this.bossMonster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.arrows = [];\n    this.keys = _keys__WEBPACK_IMPORTED_MODULE_3__[\"keysDown\"];\n    this.currentSecond = 0;\n    this.frameCount = 0;\n    this.framesLastSecond = 0;\n    this.lastFrameTime = 0; \n    this.score = 0;\n    this.phase = 0;\n    this.totalTime = 0;\n    this.bossDeathTime = 0;\n    this.bossSpawnTime = 2500;\n    this.purpleDeathTime = 0;\n    this.purpleSpawnTime = 300;\n    this.holyStartTime = 0;\n    this.holyEndTime = 2500;\n    this.drawGame = this.drawGame.bind(this);\n    this.paused = false;\n    this.scenery = new _scenery__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    this.gameOver = false;\n    this.skullPossibleSpawns = {\n      0: { pos: [12, 3], taken: false },\n      1: { pos: [22, 4], taken: false },\n      2: { pos: [20, 27], taken: false }\n    };\n    this.greenPossibleSpawns = {\n      0: { pos: [26, 8], taken: false },\n      1: { pos: [29, 10], taken: false },\n      2: { pos: [26, 14], taken: false },\n      3: { pos: [30, 16], taken: false }\n    };\n    this.purplePossibleSpawns = {\n      0: { pos: [34, 15], taken: false },\n      1: { pos: [10, 20], taken: false },\n      2: { pos: [2, 29], taken: false },\n      3: { pos: [32, 25], taken: false },\n      4: { pos: [23, 20], taken: false },\n      5: { pos: [24, 1], taken: false },\n      6: { pos: [4, 21], taken: false },\n      7: { pos: [2, 22], taken: false }\n    }\n    this.greenRespawnQueue = [];\n    this.greenMonstersInitialized = false;\n  }\n\n  /**\n   * Main game loop: handles spawning, movement, drawing, and game state updates.\n   */\n  drawGame() {\n    let currentFrameTime = Date.now();\n    let viewPort = this.board.viewPort;\n\n    // Set up possible spawn locations for red monsters\n    let redPossibleSpawns = {\n      0: { pos: [18, 12] },\n      1: { pos: [7, 8] },\n      2: { pos: [1, 7]},\n    }\n\n    let redSpawnMax = 3;\n\n    // Adjust red monster spawn max based on game phase\n    switch (this.phase) {\n      case 1:\n        redSpawnMax = 5;\n        break;\n      case 2: \n        redSpawnMax = 6;\n        break;\n      case 3: \n        redSpawnMax = 8;\n      default: \n        redSpawnMax = 2;\n    }\n\n    let skullSpawnMax = 3;\n    let greenSpawnMax = 3;\n    let purpleSpawnMax = 8;\n\n    // Spawn skull monsters if needed\n    while (this.skullMonsters.length < skullSpawnMax) {\n      let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n      for (let i = 0; i < Object.keys(this.skullPossibleSpawns).length; i ++) {\n        if (!this.skullPossibleSpawns[i].taken) {\n          monster.nextPos = this.skullPossibleSpawns[i].pos;\n          monster.spawnNum = i;\n          this.skullMonsters.push(monster);\n          this.skullPossibleSpawns[i].taken = true;\n          break\n        }\n      }\n    }\n\n    // Check for dead skull monsters and respawn them\n    for (let mon of this.skullMonsters) {\n      if (this.enemyCollision(mon)) {\n        this.score += 10;\n        this.skullPossibleSpawns[mon.spawnNum].taken = false;\n        let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        for (let i = 0; i < Object.keys(this.skullPossibleSpawns).length; i ++) {\n          if (!this.skullPossibleSpawns[i].taken) {\n            monster.nextPos = this.skullPossibleSpawns[i].pos;\n            monster.spawnNum = i;\n            this.skullMonsters.push(monster);\n            this.skullPossibleSpawns[i].taken = true;\n            break\n          }\n        }\n      }\n    }\n    \n    // Spawn red monsters if needed\n    while (this.redMonsters.length < redSpawnMax) {\n      let num = Math.floor(Math.random() * 3); \n      let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n      monster.nextPos = redPossibleSpawns[num].pos\n      this.redMonsters.push(monster);\n    }\n\n    // Check for dead red monsters and respawn them\n    for (let mon of this.redMonsters) {\n      if (this.enemyCollision(mon)) {\n        let num = Math.floor(Math.random() * 3); \n        let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        monster.nextPos = redPossibleSpawns[num].pos\n        this.redMonsters.push(monster);\n        this.score += 10;\n      }\n    }\n    \n    // Initial spawn of green monsters\n    if (!this.greenMonstersInitialized) {\n      while (this.greenMonsters.length < 3) {\n        let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        for (let i = 0; i < Object.keys(this.greenPossibleSpawns).length; i ++) {\n          if (!this.greenPossibleSpawns[i].taken) {\n            monster.nextPos = this.greenPossibleSpawns[i].pos;\n            monster.guardPoint = this.greenPossibleSpawns[i].pos;\n            monster.spawnNum = i;\n            this.greenMonsters.push(monster);\n            this.greenPossibleSpawns[i].taken = true;\n            break\n          }\n        }\n      }\n      this.greenMonstersInitialized = true;\n    }\n\n    // Check for dead green monsters and queue them for respawn\n    for (let i = this.greenMonsters.length - 1; i >= 0; i--) {\n      let mon = this.greenMonsters[i];\n      if (this.enemyCollision(mon)) {\n        this.score += 10;\n        this.greenPossibleSpawns[mon.spawnNum].taken = false;\n        // Add to respawn queue with timestamp\n        this.greenRespawnQueue.push({ time: currentFrameTime, spawnNum: mon.spawnNum });\n        this.greenMonsters.splice(i, 1);\n      }\n    }\n\n    // Handle green monster respawn delay\n    for (let i = this.greenRespawnQueue.length - 1; i >= 0; i--) {\n      let respawn = this.greenRespawnQueue[i];\n      if (currentFrameTime - respawn.time >= 5000) {\n        let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        monster.nextPos = this.greenPossibleSpawns[respawn.spawnNum].pos;\n        monster.guardPoint = this.greenPossibleSpawns[respawn.spawnNum].pos;\n        monster.spawnNum = respawn.spawnNum;\n        this.greenMonsters.push(monster);\n        this.greenPossibleSpawns[respawn.spawnNum].taken = true;\n        this.greenRespawnQueue.splice(i, 1);\n      }\n    }\n\n    // Spawn purple monsters if needed\n    while (this.purpleMonsters.length < purpleSpawnMax) {\n      let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n      for (let i = 0; i < Object.keys(this.purplePossibleSpawns).length; i ++) {\n        if (!this.purplePossibleSpawns[i].taken) {\n          monster.nextPos = this.purplePossibleSpawns[i].pos;\n          monster.spawnNum = i;\n          this.purpleMonsters.push(monster);\n          this.purplePossibleSpawns[i].taken = true;\n          break\n        }\n      }\n    }\n\n    // Check for dead purple monsters and respawn them\n    for (let mon of this.purpleMonsters) {\n      if (this.enemyCollision(mon)) {\n        this.score += 10;\n        this.purplePossibleSpawns[mon.spawnNum].taken = false;\n        let monster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        for (let i = 0; i < Object.keys(this.purplePossibleSpawns).length; i ++) {\n          if (!this.purplePossibleSpawns[i].taken) {\n            monster.nextPos = this.purplePossibleSpawns[i].pos;\n            monster.spawnNum = i;\n            this.purpleMonsters.push(monster);\n            this.purplePossibleSpawns[i].taken = true;\n            break\n          }\n        }\n      }\n    }\n\n    // Boss monster spawn/respawn logic\n    if (this.bossMonster === null && this.bossDeathTime === this.bossSpawnTime) {\n      this.bossMonster = new _monster__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n      this.bossMonster.nextPos = [17, 22];\n      this.bossMonster.guardPoint = [17, 22];\n    } else if (this.bossMonster === null && this.bossDeathTime !== this.bossSpawnTime) {\n      this.bossDeathTime += 1;\n    }\n\n    // If boss monster is killed by an arrow, add score\n    if (this.bossMonster !== null && this.enemyCollision(this.bossMonster)) this.score += 100;\n   \n    // Handle player shooting arrows\n    if (this.keys[32] && (currentFrameTime - this.player.lastArrowFired) > this.player.ROF) {\n      this.arrows.push(new _arrow__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.player.currentPos, [(this.player.currentPos[0] + this.player.shootDir[this.player.direction][0]), (this.player.currentPos[1] + this.player.shootDir[this.player.direction][1])] , this.player.mapPos, this.player.direction));\n      this.player.lastArrowFired = currentFrameTime;\n      this.keys[32] = false;\n    }\n\n    // Check for special player state (holy mode)\n    if (JSON.stringify(this.player.mapPos) === JSON.stringify([1275, 1485])) this.player.holy = true;\n\n    // Handle holy mode timing and effects\n    if (this.player.holy && this.holyStartTime !== this.holyEndTime) {\n      this.player.ROF = 150;\n      this.player.delayMove = 100;\n      this.holyStartTime += 1;\n    } else if (this.player.holy && this.holyStartTime === this.holyEndTime) {\n      this.player.holy = false;\n      this.holyStartTime = 0;\n      this.player.ROF = 400;\n      this.player.delayMove = 300;\n    }\n\n    // Handle player movement\n    if (!this.player.handleMove(currentFrameTime)) {\n      this.checkValidMove(currentFrameTime)\n    }\n    \n    // Update viewport based on player position\n    viewPort.update(this.player.mapPos[0] + (this.player.size[0] / 2), this.player.mapPos[1] + (this.player.size[1] / 2))\n    this.board.ctx.fillStyle = \"#000000\";\n\n    // Draw the background\n    this.board.ctx.fillRect(0, 0, viewPort.screen[0], viewPort.screen[1]) \n    // Draw the map tiles\n    for (let y = viewPort.startTile[1]; y < viewPort.endTile[1]; y++) {\n      for (let x = viewPort.startTile[0]; x < viewPort.endTile[0]; x++) {\n        let tile =  this.board.tileTypes[this.board.gameMap[this.player.toIndex(x, y)]];\n        this.board.ctx.drawImage(window.tileset, tile.sprite.pos[0], tile.sprite.pos[1], tile.sprite.size[0], tile.sprite.size[1], (viewPort.offset[0] + (x * this.board.tileWidth)), (viewPort.offset[1] + (y * this.board.tileHeight)), this.board.tileWidth, this.board.tileHeight)\n      }\n    }\n\n    // Draw scenery and monsters\n    let spritePlayer = this.player.sprites[this.player.direction]\n    let totalSpriteTime = 0;\n    this.scenery.drawScenery(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    this.scenery.drawTallCandle(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    this.scenery.drawLava(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    if (!this.player.holy) this.scenery.drawPotion(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n\n    // Draw all monsters\n    this.drawRedMonsters(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    this.drawSkullMonsters(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    this.drawGreenMonsters(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    this.drawPurpleMonsters(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    this.drawBossMonster(this.board.ctx, totalSpriteTime, currentFrameTime, viewPort)\n    \n    // Animate player sprite\n    for (let s in spritePlayer.frames) {\n      spritePlayer.frames[s]['start'] = totalSpriteTime;\n      totalSpriteTime += spritePlayer.aniTime;\n      spritePlayer.frames[s]['end'] = totalSpriteTime;\n    }\n\n    spritePlayer['totalSpriteDuration'] = totalSpriteTime;\n    let toon = this.getFrame(spritePlayer.frames, spritePlayer.totalSpriteDuration, currentFrameTime, this.player.moving);\n    this.board.ctx.drawImage(window.toonSet, toon.pos[0], toon.pos[1], toon.size[0], toon.size[1], (viewPort.offset[0] + this.player.mapPos[0]), (viewPort.offset[1] + this.player.mapPos[1]), this.player.size[0], this.player.size[1])\n  \n    // Handle phase changes based on time\n    switch(this.totalTime / 100) {\n      case 10:\n        this.phase = 1;\n        break;\n      case 25:\n        this.phase = 2;\n        break;\n      case 45:\n        this.phase = 3;\n        break;\n    }\n\n    // Move arrows and check for collisions\n    if (this.arrows.length > 0) {\n      for (let arrow of this.arrows) {\n        if (!arrow.handleMove(currentFrameTime)) {\n          this.arrowCheckValidMove(arrow, currentFrameTime)\n        }\n      }\n    }\n\n    // Draw all arrows\n    for(let a in this.arrows) {\n      let arrowSprite = this.arrows[a];\n      let arrowSpriteDir = arrowSprite.sprites[arrowSprite.direction].frames[0];\n      if (this.arrows.length > 0 && arrowSprite.destroyed === false) {\n        this.board.ctx.drawImage(window.arrowSet, arrowSpriteDir.pos[0], arrowSpriteDir.pos[1], arrowSpriteDir.size[0], arrowSpriteDir.size[1], viewPort.offset[0] + arrowSprite.mapPos[0], viewPort.offset[1] + arrowSprite.mapPos[1], arrowSpriteDir.size[0], arrowSpriteDir.size[1])\n      }\n    }\n\n    // Draw blood effects and remove dead monsters\n    for (let m in this.redMonsters) {\n      // For each dead red monster, play blood effect and remove from array\n      if (!this.redMonsters[m].alive) {\n        let bloodEffect = new _sfxSprite__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        for (let b in bloodEffect.frames) {\n          bloodEffect.frames[b]['start'] = totalSpriteTime;\n          totalSpriteTime += bloodEffect.aniTime;\n          bloodEffect.frames[b]['end'] = totalSpriteTime;\n        }\n        bloodEffect['totalSpriteDuration'] = totalSpriteTime;\n        let blood = this.getFrame(bloodEffect.frames, bloodEffect.totalSpriteDuration, currentFrameTime, true);\n        this.board.ctx.drawImage(window.bloodSet, blood.pos[0], blood.pos[1], blood.size[0], blood.size[1], viewPort.offset[0] + this.redMonsters[m].mapPos[0], viewPort.offset[1] + this.redMonsters[m].mapPos[1], 150, 150)\n        this.redMonsters.splice(m, 1)\n      }\n    }\n\n    for (let m in this.skullMonsters) {\n      // For each dead skull monster, play blood effect and remove from array\n      if (!this.skullMonsters[m].alive) {\n        let bloodEffect = new _sfxSprite__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        for (let b in bloodEffect.frames) {\n          bloodEffect.frames[b]['start'] = totalSpriteTime;\n          totalSpriteTime += bloodEffect.aniTime;\n          bloodEffect.frames[b]['end'] = totalSpriteTime;\n        }\n        bloodEffect['totalSpriteDuration'] = totalSpriteTime;\n        let blood = this.getFrame(bloodEffect.frames, bloodEffect.totalSpriteDuration, currentFrameTime, true);\n        this.board.ctx.drawImage(window.bloodSet, blood.pos[0], blood.pos[1], blood.size[0], blood.size[1], viewPort.offset[0] + this.skullMonsters[m].mapPos[0], viewPort.offset[1] + this.skullMonsters[m].mapPos[1], 150, 150)\n        this.skullMonsters.splice(m, 1)\n      }\n    }\n\n    for (let m in this.greenMonsters) {\n      // For each dead green monster, play blood effect and remove from array\n      if (!this.greenMonsters[m].alive) {\n        let bloodEffect = new _sfxSprite__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        for (let b in bloodEffect.frames) {\n          bloodEffect.frames[b]['start'] = totalSpriteTime;\n          totalSpriteTime += bloodEffect.aniTime;\n          bloodEffect.frames[b]['end'] = totalSpriteTime;\n        }\n        bloodEffect['totalSpriteDuration'] = totalSpriteTime;\n        let blood = this.getFrame(bloodEffect.frames, bloodEffect.totalSpriteDuration, currentFrameTime, true);\n        this.board.ctx.drawImage(window.bloodSet, blood.pos[0], blood.pos[1], blood.size[0], blood.size[1], viewPort.offset[0] + this.greenMonsters[m].mapPos[0], viewPort.offset[1] + this.greenMonsters[m].mapPos[1], 150, 150)\n        this.greenMonsters.splice(m, 1)\n      }\n    }\n\n    for (let m in this.purpleMonsters) {\n      // For each dead purple monster, play blood effect and remove from array\n      if (!this.purpleMonsters[m].alive) {\n        let bloodEffect = new _sfxSprite__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        for (let b in bloodEffect.frames) {\n          bloodEffect.frames[b]['start'] = totalSpriteTime;\n          totalSpriteTime += bloodEffect.aniTime;\n          bloodEffect.frames[b]['end'] = totalSpriteTime;\n        }\n        bloodEffect['totalSpriteDuration'] = totalSpriteTime;\n        let blood = this.getFrame(bloodEffect.frames, bloodEffect.totalSpriteDuration, currentFrameTime, true);\n        this.board.ctx.drawImage(window.bloodSet, blood.pos[0], blood.pos[1], blood.size[0], blood.size[1], viewPort.offset[0] + this.purpleMonsters[m].mapPos[0], viewPort.offset[1] + this.purpleMonsters[m].mapPos[1], 150, 150)\n        this.purpleMonsters.splice(m, 1)\n      }\n    }\n\n    if (this.bossMonster !== null) {\n    // For dead boss monster, play blood effect and reset boss state\n    if (!this.bossMonster.alive) {\n      let bloodEffect = new _sfxSprite__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n      for (let b in bloodEffect.frames) {\n        bloodEffect.frames[b]['start'] = totalSpriteTime;\n        totalSpriteTime += bloodEffect.aniTime;\n        bloodEffect.frames[b]['end'] = totalSpriteTime;\n      }\n      bloodEffect['totalSpriteDuration'] = totalSpriteTime;\n      let blood = this.getFrame(bloodEffect.frames, bloodEffect.totalSpriteDuration, currentFrameTime, true);\n      this.board.ctx.drawImage(window.bloodSet, blood.pos[0], blood.pos[1], blood.size[0], blood.size[1], viewPort.offset[0] + this.bossMonster.mapPos[0], viewPort.offset[1] + this.bossMonster.mapPos[1], 150, 150)\n      this.bossMonster = null\n      this.bossDeathTime = 0\n    }\n   }\n\n    // Update player invulnerability and check for collisions\n    this.player.updateInvulnerability(currentFrameTime);\n    this.checkCollisions(currentFrameTime);\n\n    // Remove destroyed arrows\n    for (let a in this.arrows) {\n      if (this.arrows[a].destroyed) this.arrows.splice(a, 1)\n    }\n  \n    this.lastFrameTime = currentFrameTime;\n\n    // Draw game title\n    this.board.ctx.font = \"48px Pixel\";\n    this.board.ctx.fillStyle = \"#fff\";\n    this.board.ctx.textAlign = \"center\";\n    this.board.ctx.letterSpacing = \"0px\";\n    this.board.ctx.fillText(\"VALOR\", viewPort.screen[0] / 2, 100);\n\n    // Handle game over state\n    if (this.gameOver) {\n      this.reset()\n    }\n\n    // Continue the game loop if not paused or over\n    if (!this.paused && !this.gameOver) {\n      requestAnimationFrame(this.drawGame);\n    }\n\n    // Draw health bar and check for game over\n    this.drawPlayerHealthBar();\n    if (this.player.currentHealth <= 0) {\n      this.gameOver = true;\n      this.drawGameOver();\n    }\n  }\n\n  /**\n   * Checks which direction the player can move and moves them if a key is pressed.\n   */\n  checkValidMove(currentFrameTime) {\n    if (this.keys[37] && this.player.canMoveLeft()) {\n      this.player.moveLeft(currentFrameTime);\n    } else if (this.keys[38] && this.player.canMoveUp()) {\n      this.player.moveUp(currentFrameTime);\n    } else if (this.keys[39] && this.player.canMoveRight()) {\n      this.player.moveRight(currentFrameTime);\n    } else if (this.keys[40] && this.player.canMoveDown()) {\n      this.player.moveDown(currentFrameTime);\n    }\n  }\n\n  /**\n   * Makes a monster move toward the player using pathfinding.\n   */\n  monsterSeekerCheckValidMove(monster, currentFrameTime) {\n    monster.nextPos = Object(_pathfinder__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.board.gameMap, monster.currentPos, this.player.currentPos)[1];\n    monster.timeStart = currentFrameTime;\n    monster.moving =  true;\n  }\n\n  /**\n   * Makes a monster move in a straight line, reversing direction if blocked.\n   */\n  monsterLinearCheckValidMove(monster, currentFrameTime) {\n    if (monster.direction === \"right\" ) {\n      if (monster.canMoveRight()) {\n        monster.moveRight(currentFrameTime)\n      } else {\n        monster.moveLeft(currentFrameTime)\n      }\n    } else {\n      if (monster.canMoveLeft()) {\n        monster.moveLeft(currentFrameTime)\n      } else {\n        monster.moveRight()\n      }\n    }\n    monster.timeStart = currentFrameTime;\n    monster.moving =  true;\n  }\n\n  /**\n   * Checks if the player is within a certain radius of a monster.\n   */\n  monsterProximityCheckValidMove(monster, radius) {\n    for (let i = 1; i < radius; i ++) {\n      if (JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] + i, monster.currentPos[1] ]) || JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0], monster.currentPos[1] + i ]) ) {\n        return true\n      } else if (JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] - i, monster.currentPos[1] ]) || JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0], monster.currentPos[1] - i ])) {\n        return true;\n      }\n\n      for (let j = 1; j < radius; j ++) {\n        if (JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] + i, monster.currentPos[1] + j ]) || JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] + j, monster.currentPos[1] + i ]) ) {\n          return true\n        } else if (JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] - i, monster.currentPos[1] - j ]) || JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] - j, monster.currentPos[1] - i ])) {\n          return true;\n        } else if (JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] + i, monster.currentPos[1] - j ]) || JSON.stringify(this.player.currentPos) === JSON.stringify([monster.currentPos[0] - j, monster.currentPos[1] + i ])) {\n          return true;\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks if the player is in the \"dining room\" area for green monster logic.\n   */\n  monsterDineRoomCheckValidMove() {\n    if ((this.player.currentPos[1] >= 6 && this.player.currentPos[1] <= 16) && (this.player.currentPos[0] >= 25 && this.player.currentPos[0] <= 30)) {\n      return true;\n    }\n  }\n\n  /**\n   * Checks if the player is in the \"treasure room\" area for boss monster logic.\n   */\n  monsterTreasureRoomCheckValidMove() {\n    if ((this.player.currentPos[1] >= 20 && this.player.currentPos[1] <= 26) && (this.player.currentPos[0] >= 13 && this.player.currentPos[0] <= 18)) {\n      return true;\n    }\n  }\n\n  /**\n   * Makes a monster move in a random direction.\n   */\n  randomCheckValidMove(monster, currentFrameTime){\n    let dirs = {\n      \"left\": function() {\n        if (monster.canMoveLeft()) {\n          monster.moveLeft(currentFrameTime)\n        } else {\n          monster.direction = randomDirs[Math.floor(Math.random() * 4)]\n        }\n      },\n      \"right\": function() {\n        if (monster.canMoveRight()) {\n          monster.moveRight(currentFrameTime)\n        } else {\n          monster.direction = randomDirs[Math.floor(Math.random() * 4)]\n        }\n      },\n      \"up\": function() {\n        if (monster.canMoveUp()) {\n          monster.moveUp(currentFrameTime)\n        } else {\n          monster.direction = randomDirs[Math.floor(Math.random() * 4)]\n        }\n      },\n      \"down\": function() {\n        if (monster.canMoveDown()) {\n          monster.moveDown(currentFrameTime)\n        } else {\n          monster.direction = randomDirs[Math.floor(Math.random() * 4)]\n        }\n      }\n    }\n\n    let randomDirs = [\"left\", \"right\", \"up\", \"down\"]\n    dirs[monster.direction]()\n  }\n\n  /**\n   * Moves an arrow in its current direction, or destroys it if blocked.\n   */\n  arrowCheckValidMove(arrow, currentFrameTime) {\n    if (arrow.direction === \"right\") {\n      if (arrow.canMoveRight()) {\n        arrow.moveRight(currentFrameTime);\n      } else {\n        arrow.destroyed = true;\n      }\n    } else if (arrow.direction === \"left\") {\n      if (arrow.canMoveLeft()) {\n        arrow.moveLeft(currentFrameTime);\n      } else {\n        arrow.destroyed = true;\n      }\n    } else if (arrow.direction === \"up\") {\n      if (arrow.canMoveUp()) {\n        arrow.moveUp(currentFrameTime);\n      } else {\n        arrow.destroyed = true;\n      }\n    } else if (arrow.direction === \"down\") {\n      if (arrow.canMoveDown()) {\n        arrow.moveDown(currentFrameTime);\n      } else {\n        arrow.destroyed = true;\n      }\n    }\n  }\n\n  /**\n   * Gets the correct animation frame for a sprite based on time and movement.\n   */\n  getFrame(sprites, duration, time, moving) {\n    if (!moving) return sprites[0]\n    time = time % duration;\n    for (let i in sprites) {\n      if (sprites[i].end >= time) return sprites[i];\n    }\n  }\n\n  /**\n   * Checks if a monster has been hit by an arrow and marks it as dead if so.\n   */\n  enemyCollision(monster) {\n    for (let arrow of this.arrows) {\n      if (JSON.stringify(arrow.currentPos) === JSON.stringify(monster.currentPos) && monster.alive) {\n        monster.alive = false;\n        arrow.destroyed = true;\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Toggles the game pause state.\n   */\n  togglePause() {\n    if (!this.paused) {\n      this.paused = true;\n      this.drawGame()\n    } else {\n      this.paused= false;\n      this.drawGame()\n    }\n  }\n\n  /**\n   * Shows the play again button and resets the game state.\n   */\n  reset() {\n    let playAgain = document.getElementById(\"playAgain\")\n    playAgain.hidden = !playAgain.hidden;\n  }\n\n  /**\n   * Draws all red monsters and their animations.\n   */\n  drawRedMonsters(ctx, totalSpriteTime, currentFrameTime, viewPort) {\n    // Loop through all red monsters and draw them\n    for (let m = 0; m < this.redMonsters.length; m++) {\n      if (!this.redMonsters[m].handleMove(currentFrameTime, \"red\")) {\n        this.monsterSeekerCheckValidMove(this.redMonsters[m], currentFrameTime)\n      }\n      let spriteMonster = this.redMonsters[m].sprites['red'];\n\n      for (let sm in spriteMonster.frames) {\n        spriteMonster.frames[sm]['start'] = totalSpriteTime;\n        totalSpriteTime += spriteMonster.aniTime;\n        spriteMonster.frames[sm]['end'] = totalSpriteTime;\n      }\n\n      spriteMonster['totalSpriteDuration'] = totalSpriteTime;\n      let monsterToon = this.getFrame(spriteMonster.frames, spriteMonster.totalSpriteDuration, currentFrameTime, this.redMonsters[m].moving)\n      ctx.drawImage(window.monsterSet, monsterToon.pos[0], monsterToon.pos[1], monsterToon.size[0], monsterToon.size[1], viewPort.offset[0] + this.redMonsters[m].mapPos[0], viewPort.offset[1] + this.redMonsters[m].mapPos[1], this.redMonsters[m].size[0] / 1.4, this.redMonsters[m].size[1] / 1.4)\n    }\n  }\n\n  /**\n   * Draws all skull monsters and their animations.\n   */\n  drawSkullMonsters(ctx, totalSpriteTime, currentFrameTime, viewPort) {\n    // Loop through all skull monsters and draw them\n    for (let m = 0; m < this.skullMonsters.length; m++) {\n      if (!this.skullMonsters[m].handleMove(currentFrameTime, \"skull\")) {\n        this.monsterLinearCheckValidMove(this.skullMonsters[m], currentFrameTime)\n      }\n      let spriteMonster = this.skullMonsters[m].sprites['skull'];\n      for (let sm in spriteMonster.frames) {\n        spriteMonster.frames[sm]['start'] = totalSpriteTime;\n        totalSpriteTime += spriteMonster.aniTime;\n        spriteMonster.frames[sm]['end'] = totalSpriteTime;\n      }\n      spriteMonster['totalSpriteDuration'] = totalSpriteTime;\n      let monsterToon = this.getFrame(spriteMonster.frames, spriteMonster.totalSpriteDuration, currentFrameTime, this.skullMonsters[m].moving)\n      ctx.drawImage(window.monsterSet, monsterToon.pos[0], monsterToon.pos[1], monsterToon.size[0], monsterToon.size[1], viewPort.offset[0] + this.skullMonsters[m].mapPos[0], viewPort.offset[1] + this.skullMonsters[m].mapPos[1] + 10, this.skullMonsters[m].size[0] / 2.5, this.skullMonsters[m].size[1] / 1.8)\n    }\n  }\n\n  /**\n   * Draws all green monsters and their animations.\n   */\n  drawGreenMonsters(ctx, totalSpriteTime, currentFrameTime, viewPort) {\n    // Loop through all green monsters and draw them\n    for (let m = 0; m < this.greenMonsters.length; m++) {\n      if (!this.greenMonsters[m].handleMove(currentFrameTime, \"green\")) {\n        if (this.monsterDineRoomCheckValidMove()){\n          this.greenMonsters[m].nextPos = Object(_pathfinder__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.board.gameMap, this.greenMonsters[m].currentPos, this.player.currentPos)[1]\n          this.greenMonsters[m].timeStart = currentFrameTime\n          this.greenMonsters[m].moving =  true;\n        } else {\n          if (this.greenMonsters[m].nextPos !== undefined) {\n            this.greenMonsters[m].nextPos = Object(_pathfinder__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.board.gameMap, this.greenMonsters[m].currentPos, this.greenMonsters[m].guardPoint)[1]\n            this.greenMonsters[m].timeStart = currentFrameTime\n            this.greenMonsters[m].moving =  true;\n          } else{\n            this.greenMonsters[m].moving =  false;\n          }\n        }\n      }\n      let spriteMonster = this.greenMonsters[m].sprites['green'];\n\n      for (let sm in spriteMonster.frames) {\n        spriteMonster.frames[sm]['start'] = totalSpriteTime;\n        totalSpriteTime += spriteMonster.aniTime;\n        spriteMonster.frames[sm]['end'] = totalSpriteTime;\n      }\n\n      spriteMonster['totalSpriteDuration'] = totalSpriteTime;\n      let monsterToon = this.getFrame(spriteMonster.frames, spriteMonster.totalSpriteDuration, currentFrameTime, this.greenMonsters[m].moving)\n      ctx.drawImage(window.monsterSet, monsterToon.pos[0], monsterToon.pos[1], monsterToon.size[0], monsterToon.size[1], viewPort.offset[0] + this.greenMonsters[m].mapPos[0], viewPort.offset[1] + this.greenMonsters[m].mapPos[1] + 15, this.greenMonsters[m].size[0] / 2, this.greenMonsters[m].size[1] / 2)\n    }\n  }\n\n  /**\n   * Draws all purple monsters and their animations.\n   */\n  drawPurpleMonsters(ctx, totalSpriteTime, currentFrameTime, viewPort) {\n    // Loop through all purple monsters and draw them\n    for (let m = 0; m < this.purpleMonsters.length; m++) {\n      if (!this.purpleMonsters[m].handleMove(currentFrameTime, \"purple\")) {\n        if (this.monsterProximityCheckValidMove(this.purpleMonsters[m], 4)) {\n          this.purpleMonsters[m].nextPos = Object(_pathfinder__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.board.gameMap, this.purpleMonsters[m].currentPos, this.player.currentPos)[1]\n          this.purpleMonsters[m].timeStart = currentFrameTime\n          this.purpleMonsters[m].moving =  true;\n        } else {\n          this.randomCheckValidMove(this.purpleMonsters[m], currentFrameTime)\n        }\n      }\n      let spriteMonster = this.purpleMonsters[m].sprites['purple'];\n      for (let sm in spriteMonster.frames) {\n        spriteMonster.frames[sm]['start'] = totalSpriteTime;\n        totalSpriteTime += spriteMonster.aniTime;\n        spriteMonster.frames[sm]['end'] = totalSpriteTime;\n      }\n      spriteMonster['totalSpriteDuration'] = totalSpriteTime;\n      let monsterToon = this.getFrame(spriteMonster.frames, spriteMonster.totalSpriteDuration, currentFrameTime, this.purpleMonsters[m].moving)\n      ctx.drawImage(window.monsterSet, monsterToon.pos[0], monsterToon.pos[1], monsterToon.size[0], monsterToon.size[1], viewPort.offset[0] + this.purpleMonsters[m].mapPos[0], viewPort.offset[1] + this.purpleMonsters[m].mapPos[1] + 10, this.purpleMonsters[m].size[0] / 2.5, this.purpleMonsters[m].size[1] / 1.8)\n    }\n  }\n\n  /**\n   * Draws the boss monster and its animation.\n   */\n  drawBossMonster(ctx, totalSpriteTime, currentFrameTime, viewPort) {\n    // Draw the boss monster if it exists\n    if (this.bossMonster !== null) {\n      if (!this.bossMonster.handleMove(currentFrameTime, \"boss\")) {\n        if (this.monsterTreasureRoomCheckValidMove()){\n          this.bossMonster.nextPos = Object(_pathfinder__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.board.gameMap, this.bossMonster.currentPos, this.player.currentPos)[1]\n          this.bossMonster.timeStart = currentFrameTime\n          this.bossMonster.moving =  true;\n        } else {\n          if (this.bossMonster.nextPos !== undefined) {\n            this.bossMonster.nextPos = Object(_pathfinder__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.board.gameMap, this.bossMonster.currentPos, this.bossMonster.guardPoint)[1]\n            this.bossMonster.timeStart = currentFrameTime\n            this.bossMonster.moving =  true;\n          } else{\n            this.bossMonster.moving =  false;\n          }\n        }\n      }\n      let spriteMonster = this.bossMonster.sprites['boss'];\n      for (let sm in spriteMonster.frames) {\n        spriteMonster.frames[sm]['start'] = totalSpriteTime;\n        totalSpriteTime += spriteMonster.aniTime;\n        spriteMonster.frames[sm]['end'] = totalSpriteTime;\n      }\n      spriteMonster['totalSpriteDuration'] = totalSpriteTime;\n      let monsterToon = this.getFrame(spriteMonster.frames, spriteMonster.totalSpriteDuration, currentFrameTime, this.bossMonster.moving)\n      ctx.drawImage(window.monsterSet, monsterToon.pos[0], monsterToon.pos[1], monsterToon.size[0], monsterToon.size[1], viewPort.offset[0] + this.bossMonster.mapPos[0], viewPort.offset[1] + this.bossMonster.mapPos[1], this.bossMonster.size[0] / 1.3, this.bossMonster.size[1]  )\n    }\n  }\n\n  /**\n   * Draws the player's health bar and UI elements.\n   */\n  drawPlayerHealthBar() {\n    const barWidth = 200;\n    const barHeight = 50;\n    const x = (this.board.viewPort.screen[0] - barWidth) / 2;\n    const y = 100;\n\n    // Draw the empty bar frame (always full width)\n    this.board.ctx.drawImage(window.healthbar2, x, y + 7, barWidth, barHeight);\n\n    // Calculate width of the red fill based on health (6 = full, 0 = empty)\n    let health = Math.max(0, Math.min(6, this.player.currentHealth));\n    let fillWidth = Math.floor(barWidth * (health / 6));\n\n    // Draw only the filled portion of the bar\n    if (fillWidth > 0) {\n      this.board.ctx.drawImage(\n        window.healthbar,\n        0, 0, fillWidth, barHeight,\n        x, y, fillWidth, barHeight\n      );\n    }\n\n    // Draw UI element below the hearts\n    const uiWidth = 200;\n    const uiHeight = 60;\n    const uiX = (this.board.viewPort.screen[0] - uiWidth) / 2;\n    const uiY = 150;\n    this.board.ctx.drawImage(window.ui, uiX, uiY, uiWidth, uiHeight);\n\n    this.board.ctx.font = \"38px Ancient\";\n    this.board.ctx.fillStyle = \"#fff\";\n    this.board.ctx.textAlign = \"end\";\n    this.board.ctx.letterSpacing = \"24px\";\n    this.board.ctx.fillText(this.score, uiX + 192, uiY + 40);\n  }\n\n  /**\n   * Draws the game over screen.\n   */\n  drawGameOver() {\n    // Implement the logic to draw the game over screen\n  }\n\n  /**\n   * Checks for collisions between the player and all monsters.\n   */\n  checkCollisions(currentFrameTime) {\n    // Only check collisions if player is not invulnerable\n    if (this.player.isInvulnerable) return;\n\n    // Check collisions with red monsters\n    for (let m in this.redMonsters) {\n      if (this.redMonsters[m].currentPos[0] === this.player.currentPos[0] && \n          this.redMonsters[m].currentPos[1] === this.player.currentPos[1]) {\n        this.player.takeDamage(currentFrameTime);\n        return;\n      }\n    }\n\n    // Check collisions with green monsters\n    for (let m in this.greenMonsters) {\n      if (this.greenMonsters[m].currentPos[0] === this.player.currentPos[0] && \n          this.greenMonsters[m].currentPos[1] === this.player.currentPos[1]) {\n        this.player.takeDamage(currentFrameTime);\n        return;\n      }\n    }\n\n    // Check collisions with purple monsters\n    for (let m in this.purpleMonsters) {\n      if (this.purpleMonsters[m].currentPos[0] === this.player.currentPos[0] && \n          this.purpleMonsters[m].currentPos[1] === this.player.currentPos[1]) {\n        this.player.takeDamage(currentFrameTime);\n        return;\n      }\n    }\n\n    // Check collisions with skull monsters\n    for (let m in this.skullMonsters) {\n      if (this.skullMonsters[m].currentPos[0] === this.player.currentPos[0] && \n          this.skullMonsters[m].currentPos[1] === this.player.currentPos[1]) {\n        this.player.takeDamage(currentFrameTime);\n        return;\n      }\n    }\n\n    // Check collision with boss monster\n    if (this.bossMonster && \n        this.bossMonster.currentPos[0] === this.player.currentPos[0] && \n        this.bossMonster.currentPos[1] === this.player.currentPos[1]) {\n      this.player.takeDamage(currentFrameTime);\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.js\");\n\r\n\r\nwindow.monsterSet = new Image();\r\nwindow.monsterSet.src = \"./src/images/monsterSet.png\";\r\n\r\nwindow.arrowSet = new Image();\r\nwindow.arrowSet.src = \"./src/images/arrows.png\";\r\n\r\nwindow.tileset = new Image();\r\nwindow.tileset.src = \"./src/images/dungeonTiles.png\"\r\n\r\nwindow.toonSet = new Image();\r\nwindow.toonSet.src = \"./src/images/knightFrames.png\"\r\n\r\nwindow.bloodSet = new Image();\r\nwindow.bloodSet.src = \"./src/images/bloodEffects.png\"\r\n\r\nwindow.scenery = new Image();\r\nwindow.scenery.src = \"./src/images/scenery.png\"\r\n\r\nwindow.ui = new Image();\r\nwindow.ui.src = \"./src/images/ui.png\";\r\n\r\nwindow.healthbar = new Image();\r\nwindow.healthbar.src = \"./src/images/healthbar.png\";\r\n\r\nwindow.healthbar2 = new Image();\r\nwindow.healthbar2.src = \"./src/images/healthbar2.png\";\r\n\r\n// Mobile Touch Controls\r\nlet touchStartX = 0;\r\nlet touchStartY = 0;\r\nlet lastTap = 0;\r\n\r\nconst canvas = document.querySelector('canvas');\r\n\r\nif (canvas) {\r\n  canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });\r\n  canvas.addEventListener('touchstart', function(e) {\r\n    if (e.touches.length > 1) {\r\n      e.preventDefault();\r\n    }\r\n    const touch = e.touches[0];\r\n    touchStartX = touch.clientX;\r\n    touchStartY = touch.clientY;\r\n  }, { passive: false });\r\n\r\n  // Handle movement while finger is down\r\n  canvas.addEventListener('touchmove', function(e) {\r\n    const touch = e.touches[0];\r\n    const dx = touch.clientX - touchStartX;\r\n    const dy = touch.clientY - touchStartY;\r\n    const absDx = Math.abs(dx);\r\n    const absDy = Math.abs(dy);\r\n    const swipeThreshold = 30; // px\r\n\r\n    // Clear all movement keys\r\n    window.game.keys[37] = false;\r\n    window.game.keys[38] = false;\r\n    window.game.keys[39] = false;\r\n    window.game.keys[40] = false;\r\n\r\n    // Detect direction and set key\r\n    if (absDx > absDy && absDx > swipeThreshold) {\r\n      if (dx > 0) {\r\n        window.game.keys[39] = true;\r\n      } else {\r\n        window.game.keys[37] = true;\r\n      }\r\n    } else if (absDy > absDx && absDy > swipeThreshold) {\r\n      if (dy > 0) {\r\n        window.game.keys[40] = true;\r\n      } else {\r\n        window.game.keys[38] = true;\r\n      }\r\n    }\r\n  });\r\n\r\n  // On touchend, clear all movement keys and handle shooting\r\n  canvas.addEventListener('touchend', function(e) {\r\n    window.game.keys[37] = false;\r\n    window.game.keys[38] = false;\r\n    window.game.keys[39] = false;\r\n    window.game.keys[40] = false;\r\n\r\n    \r\n    const currentTime = new Date().getTime();\r\n    const tapLength = currentTime - lastTap;\r\n    if (tapLength < 300 && tapLength > 0) {\r\n      window.game.keys[32] = true;\r\n      setTimeout(() => { window.game.keys[32] = false; }, 100);\r\n    }\r\n    lastTap = currentTime;\r\n  }, { passive: false });\r\n}\r\n\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n  const play = document.getElementById(\"play\");\r\n  play.addEventListener(\"click\", () => { \r\n    document.querySelectorAll(\".intro\")[0].setAttribute(\"hidden\", \"true\")\r\n    document.querySelectorAll(\".landingPage\")[0].style.display = \"none\";\r\n    document.querySelectorAll(\".intro\")[0].style.display = \"none\";\r\n    \r\n    let gameMusic = new Audio(\"./src/audio/Resurrections.mp3\");\r\n    gameMusic.play()\r\n    \r\n    let muteButton = document.getElementById(\"mute\");\r\n    let audioButton = document.getElementById(\"audio\");\r\n    audioButton.hidden = false;\r\n    gameMusic.muted = false;\r\n\r\n    audioButton.addEventListener(\"click\", () => {\r\n      gameMusic.muted = !gameMusic.muted;\r\n      muteButton.hidden = !muteButton.hidden;\r\n      audioButton.hidden = !audioButton.hidden;\r\n      audioButton.blur();\r\n    })\r\n\r\n    muteButton.addEventListener(\"click\", () => {\r\n      gameMusic.muted = !gameMusic.muted;\r\n      muteButton.hidden = !muteButton.hidden;\r\n      audioButton.hidden = !audioButton.hidden;\r\n      muteButton.blur();\r\n    })\r\n\r\n    let playAgain = document.getElementById(\"playAgain\")\r\n    playAgain.addEventListener(\"click\", () => {\r\n      location.reload();\r\n    })\r\n    \r\n    const game = new _game__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    window.game = game;\r\n    \r\n    window.addEventListener(\"keydown\", function(e) {\r\n      if (e.keyCode >= 37 && e.keyCode <= 40 || e.keyCode === 32) game.keys[e.keyCode] = true;   \r\n    });\r\n\r\n    window.addEventListener(\"keyup\", function(e) {\r\n      if (e.keyCode >= 37 && e.keyCode <= 40 || e.keyCode === 32) game.keys[e.keyCode] = false;   \r\n    });\r\n\r\n    window.addEventListener(\"keydown\", function(e) {\r\n      if (e.keyCode === 80) game.togglePause();\r\n    });\r\n    \r\n    game.board.viewPort.screen = [ game.board.gameBoard.width, game.board.gameBoard.height ];\r\n  \r\n    requestAnimationFrame(game.drawGame);\r\n\r\n  });\r\n\r\n  const info = document.getElementById(\"info\");\r\n  info.addEventListener(\"click\", () => {\r\n    document.querySelectorAll(\".enemyInfoBox\")[0].style.display = \"flex\";\r\n    document.querySelectorAll(\".gameBackgroundInfo\")[0].style.display = \"flex\";\r\n  });\r\n\r\n  const closeButton = document.querySelector(\".gameBackgroundInfo .closeButton\");\r\n  closeButton.addEventListener(\"click\", () => {\r\n    document.querySelectorAll(\".enemyInfoBox\")[0].style.display = \"none\";\r\n    document.querySelectorAll(\".gameBackgroundInfo\")[0].style.display = \"none\";\r\n  });\r\n\r\n  const controls = document.getElementById(\"controls\");\r\n  controls.addEventListener(\"click\", () => {\r\n    document.querySelectorAll(\".playInstructions\")[0].style.display = \"flex\";\r\n  });  \r\n\r\n  const closeControls = document.querySelector(\".playInstructions .closeButton\");\r\n  closeControls.addEventListener(\"click\", () => {\r\n    document.querySelectorAll(\".playInstructions\")[0].style.display = \"none\";\r\n  });\r\n});\r\n\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/keys.js":
/*!*********************!*\
  !*** ./src/keys.js ***!
  \*********************/
/*! exports provided: keysDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keysDown\", function() { return keysDown; });\nconst keysDown = {\r\n  37: false,\r\n  38: false,\r\n  39: false,\r\n  40: false,\r\n  32: false,\r\n  67: false\r\n};\r\n\n\n//# sourceURL=webpack:///./src/keys.js?");

/***/ }),

/***/ "./src/monster.js":
/*!************************!*\
  !*** ./src/monster.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Monster; });\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.js\");\n/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprite */ \"./src/sprite.js\");\n\r\n\r\n\r\nclass Monster {\r\n  constructor() {\r\n    this.currentPos = [17, 21]\r\n    this.nextPos = [17, 22];\r\n    this.guardPoint = [17, 22]\r\n    this.timeStart = 0;\r\n    this.delayMove = {\r\n      skull: 250,\r\n      red: 400,\r\n      green: 350,\r\n      purple: 600,\r\n      boss: 500\r\n    }\r\n    this.size = [50, 50]; \r\n    this.mapPos = [1130, 150];\r\n    this.sampleBoard = new _board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    this.direction = \"right\";\r\n    this.life = {\r\n      skull: 1,\r\n      red: 2,\r\n      green: 1,\r\n      purple: 3,\r\n      boss: 5\r\n    }\r\n    this.walkingDIR = null;\r\n    this.needToGoDIR = null;\r\n    this.stuck = false;\r\n    this.moving = true;\r\n    this.alive = true;\r\n    this.sprites = {\r\n      \"red\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [6, 7], size: [25, 32] },\r\n        1: { pos: [65, 6], size: [26, 32] },\r\n        2: { pos: [118, 3], size: [23, 37] },\r\n        3: { pos: [165, 8], size: [27, 32] }\r\n      }, 250), \r\n      \"skull\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ 0: { pos: [12, 61], size: [11, 14] },\r\n        1: { pos: [43, 61], size: [11, 14] },\r\n        2: { pos: [86, 61], size: [11, 15] },\r\n        3: { pos: [114, 61], size: [11, 14] }\r\n      }, 250),  \r\n      \"green\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ 0: { pos: [10, 93], size: [15, 13] },\r\n        1: { pos: [46, 92], size: [16, 14] },\r\n        2: { pos: [85, 92], size: [14, 14] },\r\n        3: { pos: [119, 90], size: [14, 16] }\r\n      }, 250),  \r\n      \"purple\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ 0: { pos: [10, 128], size: [13, 15] },\r\n        1: { pos: [35, 128], size: [8, 17] },\r\n        2: { pos: [67, 128], size: [13, 16] },\r\n        3: { pos: [95, 128], size: [14, 14] }\r\n      }, 250),\r\n      \"boss\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [15, 163], size: [18, 27] },\r\n        1: { pos: [62, 158], size: [20, 27] },\r\n        2: { pos: [107, 155], size: [19, 33] },\r\n        3: { pos: [152, 159], size: [20, 29] }\r\n      }, 150)\r\n    };\r\n  }\r\n  \r\n  move(x, y) {\r\n    this.currentPos = [x, y];\r\n    this.nextPos = [x, y];\r\n    this.mapPos = [\r\n      (this.sampleBoard.tileWidth * x) + ((this.sampleBoard.tileWidth - this.size[0]) / 2), \r\n      (this.sampleBoard.tileHeight * y) + ((this.sampleBoard.tileHeight - this.size[1]) / 2)\r\n    ];\r\n  }\r\n\r\n  handleMove(currentTime, type) {\r\n    if (this.nextPos) {\r\n      if (this.currentPos[0] === this.nextPos[0] && this.currentPos[1] === this.nextPos[1]) return false;\r\n\r\n      if ((currentTime - this.timeStart) >= this.delayMove[type] ) {\r\n        this.move(this.nextPos[0], this.nextPos[1]);\r\n        this.moving = !this.moving\r\n      } else {\r\n        this.getMapPos();\r\n        this.checkDirectionAndAdjust(currentTime, type);\r\n        this.mapPos[0] = Math.round(this.mapPos[0]);\r\n        this.mapPos[1] = Math.round(this.mapPos[1]);\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  getMapPos() {// \r\n    this.mapPos[0] = (this.currentPos[0] * this.sampleBoard.tileWidth) + ((this.sampleBoard.tileWidth - this.size[0]) / 2);\r\n    this.mapPos[1] = (this.currentPos[1] * this.sampleBoard.tileHeight) + ((this.sampleBoard.tileHeight - this.size[1]) / 2);\r\n  }\r\n\r\n  checkDirectionAndAdjust(currentTime, type) {\r\n    if (this.nextPos[0] !== this.currentPos[0]) {\r\n      let pixelDist = (this.sampleBoard.tileWidth / this.delayMove[type]) * (currentTime - this.timeStart);\r\n\r\n      if (this.nextPos[0] < this.currentPos[0]) {\r\n        this.mapPos[0] += (0 - pixelDist);\r\n      } else {\r\n        this.mapPos[0] += (pixelDist);\r\n      }\r\n    } else {\r\n      let pixelDist = (this.sampleBoard.tileHeight / this.delayMove[type]) * (currentTime - this.timeStart);\r\n\r\n      if (this.nextPos[1] < this.currentPos[1]) {\r\n        this.mapPos[1] += (0 - pixelDist);\r\n      } else {\r\n        this.mapPos[1] += (pixelDist);\r\n      }\r\n    }\r\n  }\r\n\r\n  toIndex(x, y) {\r\n    return ((y * this.sampleBoard.mapWidth) + x);\r\n  }\r\n\r\n  isWalkable(x, y) {\r\n    if (x < 0 || x >= this.sampleBoard.mapWidth || y < 0 || y >= this.sampleBoard.mapHeight) return false;\r\n    if (this.sampleBoard.tileTypes[this.sampleBoard.gameMap[this.toIndex(x, y)]].floor !== this.sampleBoard.floorTypes.walkable) return false; \r\n    return true;\r\n  }\r\n\r\n  canMoveUp() {\r\n    return this.isWalkable(this.currentPos[0], this.currentPos[1] - 1);\r\n  }\r\n\r\n  canMoveDown() {\r\n    return this.isWalkable(this.currentPos[0], this.currentPos[1] + 1);\r\n  }\r\n\r\n  canMoveLeft() {\r\n    return this.isWalkable(this.currentPos[0] - 1, this.currentPos[1]);\r\n  }\r\n\r\n  canMoveRight() {\r\n    return this.isWalkable(this.currentPos[0] + 1, this.currentPos[1]);\r\n  }\r\n\r\n  moveUp(currentGameTime) {\r\n    this.nextPos[1] -= 1;\r\n    this.timeStart = currentGameTime;\r\n    if (this.lastDir === \"left\") this.direction = \"left\";\r\n    this.moving = true;\r\n  }\r\n  \r\n  moveDown(currentGameTime) {\r\n    this.nextPos[1] += 1;\r\n    this.timeStart = currentGameTime;\r\n    if (this.lastDir === \"left\") this.direction = \"left\";\r\n    this.moving = true;\r\n  }\r\n\r\n  moveLeft(currentGameTime) {\r\n    this.nextPos[0] -= 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"left\";\r\n    this.moving = true; \r\n  }\r\n\r\n  moveRight(currentGameTime) {\r\n    this.nextPos[0] += 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"right\";\r\n    this.moving = true;\r\n  }\r\n}\r\n  \r\n\n\n//# sourceURL=webpack:///./src/monster.js?");

/***/ }),

/***/ "./src/pathfinder.js":
/*!***************************!*\
  !*** ./src/pathfinder.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return findPath; });\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.js\");\n\r\n\r\nlet board = new _board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\r\n\r\nfunction findPath(world, pathStart, pathEnd) { \r\n    var worldWidth = 36; \r\n\tvar worldHeight = 36; \r\n    var worldSize =\tworldWidth * worldHeight; \r\n    \r\n    var distanceFunction = ManhattanDistance;\r\n    var findNeighbours = function(){};\r\n    \r\n    function ManhattanDistance(Point, Goal) {\r\n\t\treturn Math.abs(Point.x - Goal.x) + Math.abs(Point.y - Goal.y);\r\n    }\r\n\r\n    function Neighbours(x, y) {\r\n\t\tvar\tN = y - 1,\r\n\t\tS = y + 1,\r\n\t\tE = x + 1,\r\n\t\tW = x - 1,\r\n\t\tmyN = N > -1 && canWalkHere(x, N),\r\n\t\tmyS = S < worldHeight && canWalkHere(x, S),\r\n\t\tmyE = E < worldWidth && canWalkHere(E, y),\r\n        myW = W > -1 && canWalkHere(W, y),\r\n        result = [];\r\n\t\tif (myN) result.push({x:x, y:N});\r\n        \r\n\t\tif (myE) result.push({x:E, y:y});\r\n        \r\n\t\tif (myS) result.push({x:x, y:S});\r\n        \r\n\t\tif (myW) result.push({x:W, y:y});\r\n        \r\n\t\tfindNeighbours(myN, myS, myE, myW, N, S, E, W, result);\r\n\t\treturn result;\r\n\t}\r\n    \r\n    function canWalkHere(x, y) {\r\n\t\treturn (board.tileTypes[world[x + y * 36]].floor === 1);\r\n    };\r\n    \r\n    function Node(Parent, Point) {\r\n\t\tvar newNode = {\r\n\t\t\tParent:Parent,\r\n\t\t\tvalue:Point.x + (Point.y * worldWidth),\r\n\t\t\tx:Point.x,\r\n\t\t\ty:Point.y,\r\n\t\t\tf:0,\r\n\t\t\tg:0\r\n\t\t};\r\n\r\n\t\treturn newNode;\r\n    }\r\n    \r\n    function calculatePath() {\r\n\t\tvar\tmypathStart = Node(null, {x:pathStart[0], y:pathStart[1]});\r\n\t\tvar mypathEnd = Node(null, {x:pathEnd[0], y:pathEnd[1]});\r\n\t\tvar AStar = new Array(worldSize);\r\n\t\tvar Open = [mypathStart];\r\n\t\tvar Closed = [];\r\n\t\tvar result = [];\r\n\t\tvar myNeighbours;\r\n\t\tvar myNode;\r\n\t\tvar myPath;\r\n\t\tvar length, max, min, i, j;\r\n\t\t\r\n\t\twhile(length = Open.length){\r\n\t\t\tmax = worldSize;\r\n\t\t\tmin = -1;\r\n\t\t\tfor (i = 0; i < length; i++) {\r\n\t\t\t\tif(Open[i].f < max) {\r\n\t\t\t\t\tmax = Open[i].f;\r\n\t\t\t\t\tmin = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmyNode = Open.splice(min, 1)[0];\r\n\t\t\r\n\t\t\tif (myNode.value === mypathEnd.value) {\r\n\t\t\t\tmyPath = Closed[Closed.push(myNode) - 1];\r\n\t\t\t\tdo {\r\n\t\t\t\t\tresult.push([myPath.x, myPath.y]);\r\n\t\t\t\t}\r\n\t\t\t\twhile (myPath = myPath.Parent);\r\n\t\t\t\r\n\t\t\t\tAStar = Closed = Open = [];\r\n\t\t\t\t\r\n\t\t\t\tresult.reverse();\r\n\t\t\t} else {\r\n\t\t\t\tmyNeighbours = Neighbours(myNode.x, myNode.y);\r\n\t\t\t\tfor (i = 0, j = myNeighbours.length; i < j; i++) {\r\n\t\t\t\t\tmyPath = Node(myNode, myNeighbours[i]);\r\n\t\t\t\t\tif (!AStar[myPath.value]) {\r\n\t\t\t\t\t\tmyPath.g = myNode.g + distanceFunction(myNeighbours[i], myNode);\r\n\t\t\t\t\t\tmyPath.f = myPath.g + distanceFunction(myNeighbours[i], mypathEnd);\r\n\t\t\t\t\t\tOpen.push(myPath);\r\n\t\t\t\t\t\tAStar[myPath.value] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tClosed.push(myNode);\r\n\t\t\t}\r\n\t\t} \r\n\t\treturn result;\r\n\t}\r\n\r\n    return calculatePath();\r\n}\r\n\n\n//# sourceURL=webpack:///./src/pathfinder.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Player; });\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.js\");\n/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprite */ \"./src/sprite.js\");\n\r\n\r\n\r\nclass Player {\r\n  constructor() {\r\n    this.currentPos = [1, 10];\r\n    this.nextPos = [1, 10];\r\n    this.timeStart = 0;\r\n    this.delayMove = 250;\r\n    this.size = [40, 40]; \r\n    this.mapPos = [80, 710];\r\n    this.sampleBoard = new _board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    this.direction = \"right\";\r\n    this.holy = false;\r\n    this.shootDir = {\r\n      \"right\": [1, 0],\r\n      \"left\": [-1, 0],\r\n      \"up\": [0, -1],\r\n      \"down\": [0, 1]\r\n    };\r\n    this.lastDir = \"right\"\r\n    this.moving = false;\r\n    this.ROF = 400;\r\n    this.lastArrowFired = 0;\r\n    this.maxHealth = 6;\r\n    this.currentHealth = this.maxHealth;\r\n    this.isInvulnerable = false;\r\n    this.invulnerabilityTime = 1000;\r\n    this.lastDamageTime = 0;\r\n    this.sprites = {\r\n      \"up\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [1, 84], size: [46, 43] },\r\n        1: { pos: [57, 83], size: [46, 43] },\r\n        2: { pos: [111, 85], size: [46, 43] }\r\n      }, 200), \r\n      \"right\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [5, 160], size: [35, 43] },\r\n        1: { pos: [40, 159], size: [40, 43] },\r\n        2: { pos: [85, 157], size: [40, 43] }\r\n      }, 200), \r\n      \"down\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [11, 220], size: [46, 40] },\r\n        1: { pos: [81, 220], size: [46, 40] },\r\n        2: { pos: [162, 217], size: [46, 40] }\r\n      }, 200), \r\n      \"left\": new _sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ \r\n        0: { pos: [83, 15], size: [35, 42] },\r\n        1: { pos: [46, 13], size: [36, 42] },\r\n        2: { pos: [10, 15], size: [36, 43] }\r\n      }, 200)\r\n    }\r\n  }\r\n\r\n  move(x, y) {\r\n    this.currentPos = [x, y];\r\n    this.nextPos = [x, y];\r\n    this.mapPos = [\r\n      (this.sampleBoard.tileWidth * x) + ((this.sampleBoard.tileWidth - this.size[0]) / 2), \r\n      (this.sampleBoard.tileHeight * y) + ((this.sampleBoard.tileHeight - this.size[1]) / 2)\r\n    ];\r\n  }\r\n\r\n  handleMove(currentTime) {\r\n    if (this.currentPos[0] === this.nextPos[0] && this.currentPos[1] === this.nextPos[1]) return false;\r\n    if ((currentTime - this.timeStart) >= this.delayMove ) {\r\n      this.move(this.nextPos[0], this.nextPos[1]);\r\n      this.moving = !this.moving\r\n    } else {\r\n      this.getMapPos();\r\n      this.checkDirectionAndAdjust(currentTime);\r\n      this.mapPos[0] = Math.round(this.mapPos[0]);\r\n      this.mapPos[1] = Math.round(this.mapPos[1]);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  getMapPos() {\r\n    this.mapPos[0] = (this.currentPos[0] * this.sampleBoard.tileWidth) + ((this.sampleBoard.tileWidth - this.size[0]) / 2);\r\n    this.mapPos[1] = (this.currentPos[1] * this.sampleBoard.tileHeight) + ((this.sampleBoard.tileHeight - this.size[1]) / 2);\r\n  }\r\n\r\n  checkDirectionAndAdjust(currentTime) {\r\n    if (this.nextPos[0] !== this.currentPos[0]) {\r\n      let pixelDist = (this.sampleBoard.tileWidth / this.delayMove) * (currentTime - this.timeStart);\r\n      if (this.nextPos[0] < this.currentPos[0]) {\r\n        this.mapPos[0] += (0 - pixelDist);\r\n      } else {\r\n        this.mapPos[0] += (pixelDist);\r\n      }\r\n    } else {\r\n      let pixelDist = (this.sampleBoard.tileHeight / this.delayMove) * (currentTime - this.timeStart);\r\n\r\n      if (this.nextPos[1] < this.currentPos[1]) {\r\n        this.mapPos[1] += (0 - pixelDist);\r\n      } else {\r\n        this.mapPos[1] += (pixelDist);\r\n      }\r\n    }\r\n  }\r\n\r\n  toIndex(x, y) {\r\n    return ((y * this.sampleBoard.mapWidth) + x);\r\n  }\r\n\r\n  isWalkable(x, y) {\r\n    if (x < 0 || x >= this.sampleBoard.mapWidth || y < 0 || y >= this.sampleBoard.mapHeight) return false;\r\n    if (this.sampleBoard.tileTypes[this.sampleBoard.gameMap[this.toIndex(x, y)]].floor !== this.sampleBoard.floorTypes.walkable) return false; \r\n    return true;\r\n  }\r\n\r\n  canMoveUp() {\r\n    return this.isWalkable(this.currentPos[0], this.currentPos[1] - 1);\r\n  }\r\n\r\n  canMoveDown() {\r\n    return this.isWalkable(this.currentPos[0], this.currentPos[1] + 1);\r\n  }\r\n\r\n  canMoveLeft() {\r\n    return this.isWalkable(this.currentPos[0] - 1, this.currentPos[1]);\r\n  }\r\n\r\n  canMoveRight() {\r\n    return this.isWalkable(this.currentPos[0] + 1, this.currentPos[1]);\r\n  }\r\n\r\n  moveUp(currentGameTime) {\r\n    this.nextPos[1] -= 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"up\";\r\n    this.moving = true;\r\n  }\r\n  \r\n  moveDown(currentGameTime) {\r\n    this.nextPos[1] += 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"down\";\r\n    this.moving = true;\r\n  }\r\n\r\n  moveLeft(currentGameTime) {\r\n    this.nextPos[0] -= 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"left\";\r\n    this.moving = true; \r\n  }\r\n\r\n  moveRight(currentGameTime) {\r\n    this.nextPos[0] += 1;\r\n    this.timeStart = currentGameTime;\r\n    this.direction = \"right\";\r\n    this.moving = true;\r\n  }\r\n\r\n  takeDamage(currentTime) {\r\n    if (this.isInvulnerable) return false;\r\n    \r\n    this.currentHealth--;\r\n    this.isInvulnerable = true;\r\n    this.lastDamageTime = currentTime;\r\n    \r\n    return this.currentHealth <= 0;\r\n  }\r\n\r\n  updateInvulnerability(currentTime) {\r\n    if (this.isInvulnerable && (currentTime - this.lastDamageTime) >= this.invulnerabilityTime) {\r\n      this.isInvulnerable = false;\r\n    }\r\n  }\r\n\r\n  resetHealth() {\r\n    this.currentHealth = this.maxHealth;\r\n    this.isInvulnerable = false;\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/player.js?");

/***/ }),

/***/ "./src/scenery.js":
/*!************************!*\
  !*** ./src/scenery.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Scenery; });\nclass Scenery {\r\n    constructor(frames, aniTime) {\r\n      this.frames = frames; \r\n      this.aniTime = aniTime;\r\n    }\r\n\r\n    drawScenery(ctx, totalSpriteTime, currentFrameTime, viewPort) {\r\n      let wallCandle = new Scenery({\r\n        0: { pos: [209, 29], size: [25, 28] },\r\n        1: { pos: [249, 29], size: [25, 27] },\r\n        2: { pos: [293, 30], size: [27, 28] }\r\n      }, 250);\r\n      \r\n      let spawnTwo = [ [785, 160], [975, 160], [1135, 160], [1345, 160], [1485, 1840], [1710, 1840], [1975, 1840], [295, 1145], [1135, 1145], [2325, 1210], [2325, 585]]\r\n      \r\n      for (let i in wallCandle.frames) {\r\n          wallCandle.frames[i]['start'] = totalSpriteTime;\r\n          totalSpriteTime += wallCandle.aniTime;\r\n          wallCandle.frames[i]['end'] = totalSpriteTime;\r\n      }\r\n      wallCandle['totalSpriteDuration'] = totalSpriteTime;\r\n      let wallCandleFrame = this.getFrame(wallCandle.frames, wallCandle.totalSpriteDuration, currentFrameTime, true)\r\n      for (let s in spawnTwo) {\r\n        ctx.drawImage(window.scenery, wallCandleFrame.pos[0], wallCandleFrame.pos[1], wallCandleFrame.size[0], wallCandleFrame.size[1], viewPort.offset[0] + spawnTwo[s][0], viewPort.offset[1] + spawnTwo[s][1], 30, 30)\r\n      }\r\n    \r\n      //TABLE\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1835, viewPort.offset[1] + 505, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1890, viewPort.offset[1] + 505, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1945, viewPort.offset[1] + 505, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 2000, viewPort.offset[1] + 505, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 2055, viewPort.offset[1] + 505, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1835, viewPort.offset[1] + 795, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1890, viewPort.offset[1] + 795, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1945, viewPort.offset[1] + 795, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 2000, viewPort.offset[1] + 795, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 2055, viewPort.offset[1] + 795, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1835, viewPort.offset[1] + 1065, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1890, viewPort.offset[1] + 1065, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 1945, viewPort.offset[1] + 1065, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 2000, viewPort.offset[1] + 1065, 65, 45)\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 2055, viewPort.offset[1] + 1065, 65, 45)\r\n      \r\n      //hole\r\n      ctx.drawImage(window.scenery, 207, 64, 140, 70, viewPort.offset[0] + 780, viewPort.offset[1] + 710, 140, 70)\r\n\r\n      //banner1\r\n      ctx.drawImage(window.scenery, 184, 80, 20, 35, viewPort.offset[0] + 715, viewPort.offset[1] + 510, 25, 50)\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 943, viewPort.offset[1] + 510, 20, 55)\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 1695, viewPort.offset[1] + 860, 20, 55)\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 2185, viewPort.offset[1] + 860, 20, 55)\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 855, viewPort.offset[1] + 1910, 20, 55)\r\n\r\n      //box\r\n      ctx.drawImage(window.scenery, 213, 228, 30, 32, viewPort.offset[0] + 70, viewPort.offset[1] + 900, 30, 32)\r\n      ctx.drawImage(window.scenery, 213, 228, 30, 32, viewPort.offset[0] + 2325, viewPort.offset[1] + 2025, 30, 32)\r\n\r\n      //rack \r\n      ctx.drawImage(window.scenery, 13, 226, 30, 40, viewPort.offset[0] + 1065, viewPort.offset[1] + 515, 40, 50)\r\n      ctx.drawImage(window.scenery, 63, 223, 30, 40, viewPort.offset[0] + 1135, viewPort.offset[1] + 510, 40, 50)\r\n      ctx.drawImage(window.scenery, 63, 223, 30, 40, viewPort.offset[0] + 1205, viewPort.offset[1] + 1985, 40, 50)\r\n      ctx.drawImage(window.scenery, 63, 223, 30, 40, viewPort.offset[0] + 2185, viewPort.offset[1] + 1350, 40, 50)\r\n      ctx.drawImage(window.scenery, 13, 226, 30, 40, viewPort.offset[0] + 1695, viewPort.offset[1] + 1350, 40, 50)\r\n      ctx.drawImage(window.scenery, 13, 226, 30, 40, viewPort.offset[0] + 715, viewPort.offset[1] + 1000, 40, 50)\r\n      ctx.drawImage(window.scenery, 13, 226, 30, 40, viewPort.offset[0] + 155, viewPort.offset[1] + 1425, 40, 50)\r\n\r\n      //rug\r\n      ctx.drawImage(window.scenery, 81, 300, 70, 45, viewPort.offset[0] + 670, viewPort.offset[1] + 1370, 140, 90)\r\n      ctx.drawImage(window.scenery, 81, 300, 70, 45, viewPort.offset[0] + 2240, viewPort.offset[1] + 1745, 120, 70)\r\n\r\n      //table\r\n      ctx.drawImage(window.scenery, 5, 118, 60, 40, viewPort.offset[0] + 645, viewPort.offset[1] + 1415, 65, 45)\r\n\r\n      //lamp\r\n      ctx.drawImage(window.scenery, 126, 19, 30, 45, viewPort.offset[0] + 645, viewPort.offset[1] + 1020, 30, 45)\r\n      ctx.drawImage(window.scenery, 126, 19, 30, 45, viewPort.offset[0] + 1765, viewPort.offset[1] + 395, 30, 45)\r\n      ctx.drawImage(window.scenery, 126, 19, 30, 45, viewPort.offset[0] + 2140, viewPort.offset[1] + 395, 30, 45)\r\n      ctx.drawImage(window.scenery, 126, 19, 30, 45, viewPort.offset[0] + 435, viewPort.offset[1] + 1790, 30, 45)\r\n\r\n      //chair\r\n      ctx.drawImage(window.scenery, 97, 125, 20, 30, viewPort.offset[0] + 785, viewPort.offset[1] + 1030, 25, 35)\r\n      ctx.drawImage(window.scenery, 97, 125, 20, 30, viewPort.offset[0] + 1900, viewPort.offset[1] + 765, 25, 35)\r\n      ctx.drawImage(window.scenery, 97, 125, 20, 30, viewPort.offset[0] + 1835, viewPort.offset[1] + 530, 25, 35)\r\n      ctx.drawImage(window.scenery, 97, 125, 20, 30, viewPort.offset[0] + 1900, viewPort.offset[1] + 530, 25, 35)\r\n      \r\n      //chair2\r\n      ctx.drawImage(window.scenery, 67, 125, 20, 30, viewPort.offset[0] + 2000, viewPort.offset[1] + 765, 25, 35)\r\n      ctx.drawImage(window.scenery, 67, 125, 20, 30, viewPort.offset[0] + 2100, viewPort.offset[1] + 820, 25, 35)\r\n      ctx.drawImage(window.scenery, 67, 125, 20, 30, viewPort.offset[0] + 2050, viewPort.offset[1] + 475, 25, 35)\r\n      ctx.drawImage(window.scenery, 67, 125, 20, 30, viewPort.offset[0] + 1975, viewPort.offset[1] + 1033, 25, 35)\r\n\r\n      //banner2\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 925, viewPort.offset[1] + 1140, 20, 55)\r\n      ctx.drawImage(window.scenery, 184, 80, 20, 35, viewPort.offset[0] + 1345, viewPort.offset[1] + 1140, 25, 50)\r\n      ctx.drawImage(window.scenery, 184, 80, 20, 35, viewPort.offset[0] + 435, viewPort.offset[1] + 1140, 25, 50)\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 155, viewPort.offset[1] + 1140, 20, 55)\r\n      ctx.drawImage(window.scenery, 149, 80, 20, 28, viewPort.offset[0] + 2255, viewPort.offset[1] + 1630, 20, 55)\r\n      ctx.drawImage(window.scenery, 184, 80, 20, 35, viewPort.offset[0] + 225, viewPort.offset[1] + 1770, 25, 50)\r\n      ctx.drawImage(window.scenery, 184, 80, 20, 35, viewPort.offset[0] + 1625, viewPort.offset[1] + 25, 25, 50)\r\n      ctx.drawImage(window.scenery, 184, 80, 20, 35, viewPort.offset[0] + 2185, viewPort.offset[1] + 25, 25, 50)\r\n\r\n      //chest\r\n      ctx.drawImage(window.scenery, 111, 233, 30, 30, viewPort.offset[0] + 295, viewPort.offset[1] + 1800, 30, 30)\r\n\r\n      //gate\r\n      ctx.drawImage(window.scenery, 231, 134, 42, 42, viewPort.offset[0] + 1960, viewPort.offset[1] + 17, 45, 55)\r\n      ctx.drawImage(window.scenery, 231, 134, 42, 42, viewPort.offset[0] + 1765, viewPort.offset[1] + 1345, 45, 55)\r\n      ctx.drawImage(window.scenery, 231, 134, 42, 42, viewPort.offset[0] + 225, viewPort.offset[1] + 1415, 45, 55)\r\n\r\n      //gold\r\n      ctx.drawImage(window.scenery, 10, 182, 41, 30, viewPort.offset[0] + 925, viewPort.offset[1] + 1395, 60, 49)\r\n      ctx.drawImage(window.scenery, 332, 164, 50, 53, viewPort.offset[0] + 1268, viewPort.offset[1] + 1625, 80, 83)\r\n      ctx.drawImage(window.scenery, 153, 183, 41, 30, viewPort.offset[0] + 1282, viewPort.offset[1] + 1380, 60, 49)\r\n      ctx.drawImage(window.scenery, 65, 183, 30, 28, viewPort.offset[0] + 1100, viewPort.offset[1] + 1395, 45, 43)\r\n      ctx.drawImage(window.scenery, 109, 186, 27, 22, viewPort.offset[0] + 1000, viewPort.offset[1] + 1395, 45, 40)\r\n      ctx.drawImage(window.scenery, 215, 186, 41, 30, viewPort.offset[0] + 1150, viewPort.offset[1] + 1395, 60, 40)\r\n      ctx.drawImage(window.scenery, 262, 237, 23, 17, viewPort.offset[0] + 1065, viewPort.offset[1] + 1625, 36, 30)\r\n      ctx.drawImage(window.scenery, 262, 237, 23, 17, viewPort.offset[0] + 1135, viewPort.offset[1] + 1415, 36, 30)\r\n      ctx.drawImage(window.scenery, 262, 237, 23, 17, viewPort.offset[0] + 925, viewPort.offset[1] + 1905, 30, 24)\r\n      ctx.drawImage(window.scenery, 302, 238, 23, 17, viewPort.offset[0] + 1215, viewPort.offset[1] + 1485, 36, 30)\r\n      ctx.drawImage(window.scenery, 272, 263, 4, 4, viewPort.offset[0] + 995, viewPort.offset[1] + 1555, 8, 8)\r\n      ctx.drawImage(window.scenery, 272, 263, 4, 4, viewPort.offset[0] + 925, viewPort.offset[1] + 1485, 8, 8)\r\n      ctx.drawImage(window.scenery, 289, 254, 9, 10, viewPort.offset[0] + 1135, viewPort.offset[1] + 1555, 11, 12)\r\n      ctx.drawImage(window.scenery, 262, 182, 45, 52, viewPort.offset[0] + 915, viewPort.offset[1] + 1675, 75, 82)\r\n\r\n      //chest2\r\n      ctx.drawImage(window.scenery, 157, 234, 38, 28, viewPort.offset[0] + 1250, viewPort.offset[1] + 1396, 40, 30)\r\n\r\n      //skull spawn\r\n      ctx.drawImage(window.scenery, 213, 288, 33, 41, viewPort.offset[0] + 855, viewPort.offset[1] + 200, 15, 23)\r\n      ctx.drawImage(window.scenery, 213, 288, 33, 41, viewPort.offset[0] + 1600, viewPort.offset[1] + 295, 15, 23)\r\n      ctx.drawImage(window.scenery, 213, 288, 33, 41, viewPort.offset[0] + 1415, viewPort.offset[1] + 1880, 15, 23)\r\n    }\r\n\r\n    drawTallCandle(ctx, totalSpriteTime, currentFrameTime, viewPort) {\r\n      let candle = new Scenery({\r\n        0: { pos: [19, 18], size: [16, 40] },\r\n        1: { pos: [57, 20], size: [16, 40] },\r\n        2: { pos: [91, 20], size: [16, 40] }\r\n      }, 300);\r\n      \r\n      let spawns = [ [290, 600], [360, 600], [1345, 525], [715, 1870], [2465, 1515], [2115, 1995] ]\r\n      for (let i in candle.frames) {\r\n        candle.frames[i]['start'] = totalSpriteTime;\r\n        totalSpriteTime += candle.aniTime;\r\n        candle.frames[i]['end'] = totalSpriteTime;\r\n      }\r\n      candle['totalSpriteDuration'] = totalSpriteTime;\r\n      let candleFrame = this.getFrame(candle.frames, candle.totalSpriteDuration, currentFrameTime, true)\r\n      for (let s in spawns) {\r\n        ctx.drawImage(window.scenery, candleFrame.pos[0], candleFrame.pos[1], candleFrame.size[0], candleFrame.size[1], viewPort.offset[0] + spawns[s][0], viewPort.offset[1] + spawns[s][1], candleFrame.size[0], candleFrame.size[1])\r\n      }\r\n    }\r\n\r\n    drawLava(ctx, totalSpriteTime, currentFrameTime, viewPort) {\r\n      let redFountain = new Scenery({\r\n        0: { pos: [13, 80], size: [30, 30] },\r\n        1: { pos: [58, 80], size: [30, 30] },\r\n        2: { pos: [102, 80], size: [30, 30] },\r\n        3: { pos: [13, 80], size: [30, 30] },\r\n        4: { pos: [58, 80], size: [30, 30] },\r\n        5: { pos: [102, 80], size: [30, 30] }\r\n      }, 300);\r\n      \r\n      let loc = [ [80, 460], [505, 531] ]\r\n      \r\n      for (let i in redFountain.frames) {\r\n        redFountain.frames[i]['start'] = totalSpriteTime;\r\n        totalSpriteTime += redFountain.aniTime;\r\n        redFountain.frames[i]['end'] = totalSpriteTime;\r\n      }\r\n      redFountain['totalSpriteDuration'] = totalSpriteTime;\r\n      let redFountainFrame = this.getFrame(redFountain.frames, redFountain.totalSpriteDuration, currentFrameTime, true)\r\n      for (let s in loc) {\r\n        ctx.drawImage(window.scenery, redFountainFrame.pos[0], redFountainFrame.pos[1], redFountainFrame.size[0], redFountainFrame.size[1], viewPort.offset[0] + loc[s][0], viewPort.offset[1] + loc[s][1], 30, 30)\r\n      }\r\n\r\n      ctx.drawImage(window.scenery, 179, 293, 11, 31, viewPort.offset[0] + 1322, viewPort.offset[1] + 855, 11, 31)\r\n    }\r\n\r\n    drawPotion(ctx, totalSpriteTime, currentFrameTime, viewPort) {\r\n      let potion = new Scenery({\r\n        0: { pos: [18, 388], size: [8, 11] },\r\n        1: { pos: [37, 388], size: [8, 11] },\r\n        2: { pos: [54, 388], size: [8, 11] },\r\n        3: { pos: [71, 388], size: [8, 11] }\r\n      }, 50);\r\n    \r\n      for (let i in potion.frames) {\r\n        potion.frames[i]['start'] = totalSpriteTime;\r\n        totalSpriteTime += potion.aniTime;\r\n        potion.frames[i]['end'] = totalSpriteTime;\r\n      }\r\n      potion['totalSpriteDuration'] = totalSpriteTime;\r\n      let potionFrame = this.getFrame(potion.frames, potion.totalSpriteDuration, currentFrameTime, true);\r\n      ctx.drawImage(window.scenery, potionFrame.pos[0], potionFrame.pos[1], potionFrame.size[0], potionFrame.size[1], viewPort.offset[0] + 1275, viewPort.offset[1] + 1485, potionFrame.size[0] * 1.3, potionFrame.size[1] * 1.3)\r\n    }\r\n\r\n    getFrame(sprites, duration, time, moving) {\r\n      if (!moving) return sprites[0]\r\n      time = time % duration;\r\n      for (let i in sprites) {\r\n        if (sprites[i].end >= time) return sprites[i];\r\n      }\r\n    }\r\n}\n\n//# sourceURL=webpack:///./src/scenery.js?");

/***/ }),

/***/ "./src/sfxSprite.js":
/*!**************************!*\
  !*** ./src/sfxSprite.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SFXSprite; });\nclass SFXSprite {\r\n  constructor() {\r\n    this.frames = {\r\n      0: { pos: [63, 191], size: [80, 80]},\r\n      1: { pos: [176, 60], size: [80, 80]},\r\n      2: { pos: [63, 190], size: [80, 80]},\r\n      3: { pos: [176, 188], size: [80, 80]},\r\n      4: { pos: [63, 312], size: [80, 80]},\r\n      5: { pos: [287, 190], size: [80, 80]},\r\n      6: { pos: [287, 190], size: [80, 80]},\r\n      7: { pos: [287, 190], size: [80, 80]},\r\n      8: { pos: [287, 190], size: [80, 80]},\r\n      9: { pos: [287, 190], size: [80, 80]},  \r\n    }; \r\n    this.aniTime = 200;\r\n  }\r\n};\n\n//# sourceURL=webpack:///./src/sfxSprite.js?");

/***/ }),

/***/ "./src/sprite.js":
/*!***********************!*\
  !*** ./src/sprite.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Sprite; });\nclass Sprite {\r\n  constructor(frames, aniTime) {\r\n    this.frames = frames; \r\n    this.aniTime = aniTime;\r\n  }   \r\n};\n\n//# sourceURL=webpack:///./src/sprite.js?");

/***/ }),

/***/ "./src/tile.js":
/*!*********************!*\
  !*** ./src/tile.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Tile; });\nclass Tile {\r\n  constructor(pos, size) { \r\n    this.pos = pos;\r\n    this.size = size;\r\n  }\r\n}; \n\n//# sourceURL=webpack:///./src/tile.js?");

/***/ })

/******/ });